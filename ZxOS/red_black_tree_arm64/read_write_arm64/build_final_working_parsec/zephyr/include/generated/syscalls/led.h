
/* auto-generated by gen_syscalls.py, don't edit */
#ifndef Z_INCLUDE_SYSCALLS_LED_H
#define Z_INCLUDE_SYSCALLS_LED_H


#include <tracing/tracing_syscall.h>

#ifndef _ASMLANGUAGE

#include <syscall_list.h>
#include <syscall.h>

#include <linker/sections.h>


#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
#pragma GCC diagnostic push
#endif

#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#if !defined(__XCC__)
#pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern int z_impl_led_blink(const struct device * dev, uint32_t led, uint32_t delay_on, uint32_t delay_off);

__pinned_func
static inline int led_blink(const struct device * dev, uint32_t led, uint32_t delay_on, uint32_t delay_off)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke4(*(uintptr_t *)&dev, *(uintptr_t *)&led, *(uintptr_t *)&delay_on, *(uintptr_t *)&delay_off, K_SYSCALL_LED_BLINK);
	}
#endif
	compiler_barrier();
	return z_impl_led_blink(dev, led, delay_on, delay_off);
}

#if (CONFIG_TRACING_SYSCALL == 1)
#ifndef DISABLE_SYSCALL_TRACING

#define led_blink(dev, led, delay_on, delay_off) ({ 	int retval; 	sys_port_trace_syscall_enter(K_SYSCALL_LED_BLINK, led_blink, dev, led, delay_on, delay_off); 	retval = led_blink(dev, led, delay_on, delay_off); 	sys_port_trace_syscall_exit(K_SYSCALL_LED_BLINK, led_blink, dev, led, delay_on, delay_off, retval); 	retval; })
#endif
#endif


extern int z_impl_led_get_info(const struct device * dev, uint32_t led, const struct led_info ** info);

__pinned_func
static inline int led_get_info(const struct device * dev, uint32_t led, const struct led_info ** info)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&led, *(uintptr_t *)&info, K_SYSCALL_LED_GET_INFO);
	}
#endif
	compiler_barrier();
	return z_impl_led_get_info(dev, led, info);
}

#if (CONFIG_TRACING_SYSCALL == 1)
#ifndef DISABLE_SYSCALL_TRACING

#define led_get_info(dev, led, info) ({ 	int retval; 	sys_port_trace_syscall_enter(K_SYSCALL_LED_GET_INFO, led_get_info, dev, led, info); 	retval = led_get_info(dev, led, info); 	sys_port_trace_syscall_exit(K_SYSCALL_LED_GET_INFO, led_get_info, dev, led, info, retval); 	retval; })
#endif
#endif


extern int z_impl_led_set_brightness(const struct device * dev, uint32_t led, uint8_t value);

__pinned_func
static inline int led_set_brightness(const struct device * dev, uint32_t led, uint8_t value)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&led, *(uintptr_t *)&value, K_SYSCALL_LED_SET_BRIGHTNESS);
	}
#endif
	compiler_barrier();
	return z_impl_led_set_brightness(dev, led, value);
}

#if (CONFIG_TRACING_SYSCALL == 1)
#ifndef DISABLE_SYSCALL_TRACING

#define led_set_brightness(dev, led, value) ({ 	int retval; 	sys_port_trace_syscall_enter(K_SYSCALL_LED_SET_BRIGHTNESS, led_set_brightness, dev, led, value); 	retval = led_set_brightness(dev, led, value); 	sys_port_trace_syscall_exit(K_SYSCALL_LED_SET_BRIGHTNESS, led_set_brightness, dev, led, value, retval); 	retval; })
#endif
#endif


extern int z_impl_led_write_channels(const struct device * dev, uint32_t start_channel, uint32_t num_channels, const uint8_t * buf);

__pinned_func
static inline int led_write_channels(const struct device * dev, uint32_t start_channel, uint32_t num_channels, const uint8_t * buf)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke4(*(uintptr_t *)&dev, *(uintptr_t *)&start_channel, *(uintptr_t *)&num_channels, *(uintptr_t *)&buf, K_SYSCALL_LED_WRITE_CHANNELS);
	}
#endif
	compiler_barrier();
	return z_impl_led_write_channels(dev, start_channel, num_channels, buf);
}

#if (CONFIG_TRACING_SYSCALL == 1)
#ifndef DISABLE_SYSCALL_TRACING

#define led_write_channels(dev, start_channel, num_channels, buf) ({ 	int retval; 	sys_port_trace_syscall_enter(K_SYSCALL_LED_WRITE_CHANNELS, led_write_channels, dev, start_channel, num_channels, buf); 	retval = led_write_channels(dev, start_channel, num_channels, buf); 	sys_port_trace_syscall_exit(K_SYSCALL_LED_WRITE_CHANNELS, led_write_channels, dev, start_channel, num_channels, buf, retval); 	retval; })
#endif
#endif


extern int z_impl_led_set_channel(const struct device * dev, uint32_t channel, uint8_t value);

__pinned_func
static inline int led_set_channel(const struct device * dev, uint32_t channel, uint8_t value)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&channel, *(uintptr_t *)&value, K_SYSCALL_LED_SET_CHANNEL);
	}
#endif
	compiler_barrier();
	return z_impl_led_set_channel(dev, channel, value);
}

#if (CONFIG_TRACING_SYSCALL == 1)
#ifndef DISABLE_SYSCALL_TRACING

#define led_set_channel(dev, channel, value) ({ 	int retval; 	sys_port_trace_syscall_enter(K_SYSCALL_LED_SET_CHANNEL, led_set_channel, dev, channel, value); 	retval = led_set_channel(dev, channel, value); 	sys_port_trace_syscall_exit(K_SYSCALL_LED_SET_CHANNEL, led_set_channel, dev, channel, value, retval); 	retval; })
#endif
#endif


extern int z_impl_led_set_color(const struct device * dev, uint32_t led, uint8_t num_colors, const uint8_t * color);

__pinned_func
static inline int led_set_color(const struct device * dev, uint32_t led, uint8_t num_colors, const uint8_t * color)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke4(*(uintptr_t *)&dev, *(uintptr_t *)&led, *(uintptr_t *)&num_colors, *(uintptr_t *)&color, K_SYSCALL_LED_SET_COLOR);
	}
#endif
	compiler_barrier();
	return z_impl_led_set_color(dev, led, num_colors, color);
}

#if (CONFIG_TRACING_SYSCALL == 1)
#ifndef DISABLE_SYSCALL_TRACING

#define led_set_color(dev, led, num_colors, color) ({ 	int retval; 	sys_port_trace_syscall_enter(K_SYSCALL_LED_SET_COLOR, led_set_color, dev, led, num_colors, color); 	retval = led_set_color(dev, led, num_colors, color); 	sys_port_trace_syscall_exit(K_SYSCALL_LED_SET_COLOR, led_set_color, dev, led, num_colors, color, retval); 	retval; })
#endif
#endif


extern int z_impl_led_on(const struct device * dev, uint32_t led);

__pinned_func
static inline int led_on(const struct device * dev, uint32_t led)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&dev, *(uintptr_t *)&led, K_SYSCALL_LED_ON);
	}
#endif
	compiler_barrier();
	return z_impl_led_on(dev, led);
}

#if (CONFIG_TRACING_SYSCALL == 1)
#ifndef DISABLE_SYSCALL_TRACING

#define led_on(dev, led) ({ 	int retval; 	sys_port_trace_syscall_enter(K_SYSCALL_LED_ON, led_on, dev, led); 	retval = led_on(dev, led); 	sys_port_trace_syscall_exit(K_SYSCALL_LED_ON, led_on, dev, led, retval); 	retval; })
#endif
#endif


extern int z_impl_led_off(const struct device * dev, uint32_t led);

__pinned_func
static inline int led_off(const struct device * dev, uint32_t led)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&dev, *(uintptr_t *)&led, K_SYSCALL_LED_OFF);
	}
#endif
	compiler_barrier();
	return z_impl_led_off(dev, led);
}

#if (CONFIG_TRACING_SYSCALL == 1)
#ifndef DISABLE_SYSCALL_TRACING

#define led_off(dev, led) ({ 	int retval; 	sys_port_trace_syscall_enter(K_SYSCALL_LED_OFF, led_off, dev, led); 	retval = led_off(dev, led); 	sys_port_trace_syscall_exit(K_SYSCALL_LED_OFF, led_off, dev, led, retval); 	retval; })
#endif
#endif


#ifdef __cplusplus
}
#endif

#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
#pragma GCC diagnostic pop
#endif

#endif
#endif /* include guard */
