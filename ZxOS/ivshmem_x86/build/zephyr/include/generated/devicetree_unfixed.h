/*
 * Generated by gen_defines.py
 *
 * DTS input file:
 *   qemu_x86_64.dts.pre.tmp
 *
 * Directories with bindings:
 *   $ZEPHYR_BASE/dts/bindings
 *
 * Node dependency ordering (ordinal and path):
 *   0   /
 *   1   /aliases
 *   2   /chosen
 *   3   /eeprom0
 *   4   /sim_flash
 *   5   /sim_flash/flash_sim@0
 *   6   /sim_flash/flash_sim@0/partitions
 *   7   /sim_flash/flash_sim@0/partitions/partition@31000
 *   8   /eeprom1
 *   9   /flash@500000
 *   10  /memory@0
 *   11  /cpus
 *   12  /cpus/cpu@0
 *   13  /sim_flash/flash_sim@0/partitions/partition@1000
 *   14  /sim_flash/flash_sim@0/partitions/partition@11000
 *   15  /sim_flash/flash_sim@0/partitions/partition@21000
 *   16  /ioapic@fec00000
 *   17  /soc
 *   18  /soc/eth@febc0000
 *   19  /soc/hpet@fed00000
 *   20  /soc/uart@2f8
 *   21  /soc/uart@3f8
 *
 * Definitions derived from these nodes in dependency order are next,
 * followed by /chosen nodes.
 */

/*
 * Devicetree node: /
 *
 * Node identifier: DT_N
 */

/* Node's full path: */
#define DT_N_PATH "/"

/* Node's name with unit-address: */
#define DT_N_FULL_NAME "/"
#define DT_N_FOREACH_CHILD(fn) fn(DT_N_S_chosen) fn(DT_N_S_aliases) fn(DT_N_S_cpus) fn(DT_N_S_ioapic_fec00000) fn(DT_N_S_memory_0) fn(DT_N_S_soc) fn(DT_N_S_flash_500000) fn(DT_N_S_sim_flash) fn(DT_N_S_eeprom1) fn(DT_N_S_eeprom0)
#define DT_N_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_chosen, __VA_ARGS__) fn(DT_N_S_aliases, __VA_ARGS__) fn(DT_N_S_cpus, __VA_ARGS__) fn(DT_N_S_ioapic_fec00000, __VA_ARGS__) fn(DT_N_S_memory_0, __VA_ARGS__) fn(DT_N_S_soc, __VA_ARGS__) fn(DT_N_S_flash_500000, __VA_ARGS__) fn(DT_N_S_sim_flash, __VA_ARGS__) fn(DT_N_S_eeprom1, __VA_ARGS__) fn(DT_N_S_eeprom0, __VA_ARGS__)
#define DT_N_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_chosen) fn(DT_N_S_aliases) fn(DT_N_S_cpus) fn(DT_N_S_ioapic_fec00000) fn(DT_N_S_memory_0) fn(DT_N_S_soc) fn(DT_N_S_flash_500000) fn(DT_N_S_sim_flash) fn(DT_N_S_eeprom1) fn(DT_N_S_eeprom0) 
#define DT_N_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_chosen, __VA_ARGS__) fn(DT_N_S_aliases, __VA_ARGS__) fn(DT_N_S_cpus, __VA_ARGS__) fn(DT_N_S_ioapic_fec00000, __VA_ARGS__) fn(DT_N_S_memory_0, __VA_ARGS__) fn(DT_N_S_soc, __VA_ARGS__) fn(DT_N_S_flash_500000, __VA_ARGS__) fn(DT_N_S_sim_flash, __VA_ARGS__) fn(DT_N_S_eeprom1, __VA_ARGS__) fn(DT_N_S_eeprom0, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_ORD 0

/* Ordinals for what this node depends on directly: */
#define DT_N_REQUIRES_ORDS /* nothing */

/* Ordinals for what depends directly on this node: */
#define DT_N_SUPPORTS_ORDS \
	1, /* /aliases */ \
	2, /* /chosen */ \
	3, /* /eeprom0 */ \
	4, /* /sim_flash */ \
	8, /* /eeprom1 */ \
	9, /* /flash@500000 */ \
	10, /* /memory@0 */ \
	11, /* /cpus */ \
	16, /* /ioapic@fec00000 */ \
	17, /* /soc */

/* Existence and alternate IDs: */
#define DT_N_EXISTS 1
#define DT_N_INST_0_qemu_x86_emulator DT_N

/* Macros for properties that are special in the specification: */
#define DT_N_REG_NUM 0
#define DT_N_IRQ_NUM 0
#define DT_N_COMPAT_MATCHES_qemu_x86_emulator 1
#define DT_N_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_P_compatible {"qemu,x86_emulator"}
#define DT_N_P_compatible_IDX_0 "qemu,x86_emulator"
#define DT_N_P_compatible_IDX_0_EXISTS 1
#define DT_N_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N, compatible, 0)
#define DT_N_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N, compatible, 0, __VA_ARGS__)
#define DT_N_P_compatible_LEN 1
#define DT_N_P_compatible_EXISTS 1

/*
 * Devicetree node: /aliases
 *
 * Node identifier: DT_N_S_aliases
 */

/* Node's full path: */
#define DT_N_S_aliases_PATH "/aliases"

/* Node's name with unit-address: */
#define DT_N_S_aliases_FULL_NAME "aliases"

/* Node parent (/) identifier: */
#define DT_N_S_aliases_PARENT DT_N
#define DT_N_S_aliases_FOREACH_CHILD(fn) 
#define DT_N_S_aliases_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_aliases_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_aliases_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_aliases_ORD 1

/* Ordinals for what this node depends on directly: */
#define DT_N_S_aliases_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_aliases_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_aliases_EXISTS 1

/* Macros for properties that are special in the specification: */
#define DT_N_S_aliases_REG_NUM 0
#define DT_N_S_aliases_IRQ_NUM 0
#define DT_N_S_aliases_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_aliases_PINCTRL_NUM 0

/* (No generic property macros) */

/*
 * Devicetree node: /chosen
 *
 * Node identifier: DT_N_S_chosen
 */

/* Node's full path: */
#define DT_N_S_chosen_PATH "/chosen"

/* Node's name with unit-address: */
#define DT_N_S_chosen_FULL_NAME "chosen"

/* Node parent (/) identifier: */
#define DT_N_S_chosen_PARENT DT_N
#define DT_N_S_chosen_FOREACH_CHILD(fn) 
#define DT_N_S_chosen_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_chosen_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_chosen_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_chosen_ORD 2

/* Ordinals for what this node depends on directly: */
#define DT_N_S_chosen_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_chosen_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_chosen_EXISTS 1

/* Macros for properties that are special in the specification: */
#define DT_N_S_chosen_REG_NUM 0
#define DT_N_S_chosen_IRQ_NUM 0
#define DT_N_S_chosen_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_chosen_PINCTRL_NUM 0

/* (No generic property macros) */

/*
 * Devicetree node: /eeprom0
 *
 * Node identifier: DT_N_S_eeprom0
 *
 * Binding (compatible = zephyr,sim-eeprom):
 *   $ZEPHYR_BASE/dts/bindings/mtd/zephyr,sim-eeprom.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_eeprom0_PATH "/eeprom0"

/* Node's name with unit-address: */
#define DT_N_S_eeprom0_FULL_NAME "eeprom0"

/* Node parent (/) identifier: */
#define DT_N_S_eeprom0_PARENT DT_N
#define DT_N_S_eeprom0_FOREACH_CHILD(fn) 
#define DT_N_S_eeprom0_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_eeprom0_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_eeprom0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_eeprom0_ORD 3

/* Ordinals for what this node depends on directly: */
#define DT_N_S_eeprom0_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_eeprom0_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_eeprom0_EXISTS 1
#define DT_N_ALIAS_eeprom_0           DT_N_S_eeprom0
#define DT_N_INST_0_zephyr_sim_eeprom DT_N_S_eeprom0
#define DT_N_NODELABEL_eeprom0        DT_N_S_eeprom0

/* Macros for properties that are special in the specification: */
#define DT_N_S_eeprom0_REG_NUM 0
#define DT_N_S_eeprom0_IRQ_NUM 0
#define DT_N_S_eeprom0_COMPAT_MATCHES_zephyr_sim_eeprom 1
#define DT_N_S_eeprom0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_eeprom0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_eeprom0_P_size 4096
#define DT_N_S_eeprom0_P_size_EXISTS 1
#define DT_N_S_eeprom0_P_read_only 0
#define DT_N_S_eeprom0_P_read_only_EXISTS 1
#define DT_N_S_eeprom0_P_label "EEPROM_0"
#define DT_N_S_eeprom0_P_label_STRING_TOKEN EEPROM_0
#define DT_N_S_eeprom0_P_label_STRING_UPPER_TOKEN EEPROM_0
#define DT_N_S_eeprom0_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_eeprom0, label, 0) \
	fn(DT_N_S_eeprom0, label, 1) \
	fn(DT_N_S_eeprom0, label, 2) \
	fn(DT_N_S_eeprom0, label, 3) \
	fn(DT_N_S_eeprom0, label, 4) \
	fn(DT_N_S_eeprom0, label, 5) \
	fn(DT_N_S_eeprom0, label, 6) \
	fn(DT_N_S_eeprom0, label, 7)
#define DT_N_S_eeprom0_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_eeprom0, label, 0, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, label, 1, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, label, 2, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, label, 3, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, label, 4, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, label, 5, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, label, 6, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, label, 7, __VA_ARGS__)
#define DT_N_S_eeprom0_P_label_EXISTS 1
#define DT_N_S_eeprom0_P_status "okay"
#define DT_N_S_eeprom0_P_status_STRING_TOKEN okay
#define DT_N_S_eeprom0_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_eeprom0_P_status_ENUM_IDX 1
#define DT_N_S_eeprom0_P_status_ENUM_TOKEN okay
#define DT_N_S_eeprom0_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_eeprom0_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_eeprom0, status, 0) \
	fn(DT_N_S_eeprom0, status, 1) \
	fn(DT_N_S_eeprom0, status, 2) \
	fn(DT_N_S_eeprom0, status, 3)
#define DT_N_S_eeprom0_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_eeprom0, status, 0, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, status, 1, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, status, 2, __VA_ARGS__) \
	fn(DT_N_S_eeprom0, status, 3, __VA_ARGS__)
#define DT_N_S_eeprom0_P_status_EXISTS 1
#define DT_N_S_eeprom0_P_compatible {"zephyr,sim-eeprom"}
#define DT_N_S_eeprom0_P_compatible_IDX_0 "zephyr,sim-eeprom"
#define DT_N_S_eeprom0_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_eeprom0_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_eeprom0, compatible, 0)
#define DT_N_S_eeprom0_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_eeprom0, compatible, 0, __VA_ARGS__)
#define DT_N_S_eeprom0_P_compatible_LEN 1
#define DT_N_S_eeprom0_P_compatible_EXISTS 1
#define DT_N_S_eeprom0_P_wakeup_source 0
#define DT_N_S_eeprom0_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /sim_flash
 *
 * Node identifier: DT_N_S_sim_flash
 *
 * Binding (compatible = zephyr,sim-flash):
 *   $ZEPHYR_BASE/dts/bindings/flash_controller/zephyr,sim-flash.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_sim_flash_PATH "/sim_flash"

/* Node's name with unit-address: */
#define DT_N_S_sim_flash_FULL_NAME "sim_flash"

/* Node parent (/) identifier: */
#define DT_N_S_sim_flash_PARENT DT_N
#define DT_N_S_sim_flash_FOREACH_CHILD(fn) fn(DT_N_S_sim_flash_S_flash_sim_0)
#define DT_N_S_sim_flash_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0, __VA_ARGS__)
#define DT_N_S_sim_flash_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_sim_flash_S_flash_sim_0) 
#define DT_N_S_sim_flash_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_sim_flash_ORD 4

/* Ordinals for what this node depends on directly: */
#define DT_N_S_sim_flash_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_sim_flash_SUPPORTS_ORDS \
	5, /* /sim_flash/flash_sim@0 */

/* Existence and alternate IDs: */
#define DT_N_S_sim_flash_EXISTS 1
#define DT_N_INST_0_zephyr_sim_flash DT_N_S_sim_flash
#define DT_N_NODELABEL_sim_flash     DT_N_S_sim_flash

/* Macros for properties that are special in the specification: */
#define DT_N_S_sim_flash_REG_NUM 0
#define DT_N_S_sim_flash_IRQ_NUM 0
#define DT_N_S_sim_flash_COMPAT_MATCHES_zephyr_sim_flash 1
#define DT_N_S_sim_flash_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_sim_flash_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_sim_flash_P_label "FLASH_SIMULATOR"
#define DT_N_S_sim_flash_P_label_STRING_TOKEN FLASH_SIMULATOR
#define DT_N_S_sim_flash_P_label_STRING_UPPER_TOKEN FLASH_SIMULATOR
#define DT_N_S_sim_flash_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash, label, 0) \
	fn(DT_N_S_sim_flash, label, 1) \
	fn(DT_N_S_sim_flash, label, 2) \
	fn(DT_N_S_sim_flash, label, 3) \
	fn(DT_N_S_sim_flash, label, 4) \
	fn(DT_N_S_sim_flash, label, 5) \
	fn(DT_N_S_sim_flash, label, 6) \
	fn(DT_N_S_sim_flash, label, 7) \
	fn(DT_N_S_sim_flash, label, 8) \
	fn(DT_N_S_sim_flash, label, 9) \
	fn(DT_N_S_sim_flash, label, 10) \
	fn(DT_N_S_sim_flash, label, 11) \
	fn(DT_N_S_sim_flash, label, 12) \
	fn(DT_N_S_sim_flash, label, 13) \
	fn(DT_N_S_sim_flash, label, 14)
#define DT_N_S_sim_flash_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash, label, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 1, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 2, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 3, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 4, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 5, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 6, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 7, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 8, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 9, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 10, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 11, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 12, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 13, __VA_ARGS__) \
	fn(DT_N_S_sim_flash, label, 14, __VA_ARGS__)
#define DT_N_S_sim_flash_P_label_EXISTS 1
#define DT_N_S_sim_flash_P_erase_value 255
#define DT_N_S_sim_flash_P_erase_value_EXISTS 1
#define DT_N_S_sim_flash_P_compatible {"zephyr,sim-flash"}
#define DT_N_S_sim_flash_P_compatible_IDX_0 "zephyr,sim-flash"
#define DT_N_S_sim_flash_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash, compatible, 0)
#define DT_N_S_sim_flash_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash, compatible, 0, __VA_ARGS__)
#define DT_N_S_sim_flash_P_compatible_LEN 1
#define DT_N_S_sim_flash_P_compatible_EXISTS 1
#define DT_N_S_sim_flash_P_wakeup_source 0
#define DT_N_S_sim_flash_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /sim_flash/flash_sim@0
 *
 * Node identifier: DT_N_S_sim_flash_S_flash_sim_0
 *
 * Binding (compatible = soc-nv-flash):
 *   $ZEPHYR_BASE/dts/bindings/mtd/soc-nv-flash.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_sim_flash_S_flash_sim_0_PATH "/sim_flash/flash_sim@0"

/* Node's name with unit-address: */
#define DT_N_S_sim_flash_S_flash_sim_0_FULL_NAME "flash_sim@0"

/* Node parent (/sim_flash) identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_PARENT DT_N_S_sim_flash
#define DT_N_S_sim_flash_S_flash_sim_0_FOREACH_CHILD(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions)
#define DT_N_S_sim_flash_S_flash_sim_0_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions) 
#define DT_N_S_sim_flash_S_flash_sim_0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_sim_flash_S_flash_sim_0_ORD 5

/* Ordinals for what this node depends on directly: */
#define DT_N_S_sim_flash_S_flash_sim_0_REQUIRES_ORDS \
	4, /* /sim_flash */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_sim_flash_S_flash_sim_0_SUPPORTS_ORDS \
	6, /* /sim_flash/flash_sim@0/partitions */

/* Existence and alternate IDs: */
#define DT_N_S_sim_flash_S_flash_sim_0_EXISTS 1
#define DT_N_INST_1_soc_nv_flash  DT_N_S_sim_flash_S_flash_sim_0
#define DT_N_NODELABEL_flash_sim0 DT_N_S_sim_flash_S_flash_sim_0

/* Macros for properties that are special in the specification: */
#define DT_N_S_sim_flash_S_flash_sim_0_REG_NUM 1
#define DT_N_S_sim_flash_S_flash_sim_0_REG_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_REG_IDX_0_VAL_ADDRESS 0 /* 0x0 */
#define DT_N_S_sim_flash_S_flash_sim_0_REG_IDX_0_VAL_SIZE 1048576 /* 0x100000 */
#define DT_N_S_sim_flash_S_flash_sim_0_IRQ_NUM 0
#define DT_N_S_sim_flash_S_flash_sim_0_COMPAT_MATCHES_soc_nv_flash 1
#define DT_N_S_sim_flash_S_flash_sim_0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_sim_flash_S_flash_sim_0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_sim_flash_S_flash_sim_0_P_erase_block_size 1024
#define DT_N_S_sim_flash_S_flash_sim_0_P_erase_block_size_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_P_write_block_size 4
#define DT_N_S_sim_flash_S_flash_sim_0_P_write_block_size_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_P_compatible {"soc-nv-flash"}
#define DT_N_S_sim_flash_S_flash_sim_0_P_compatible_IDX_0 "soc-nv-flash"
#define DT_N_S_sim_flash_S_flash_sim_0_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0, compatible, 0)
#define DT_N_S_sim_flash_S_flash_sim_0_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0, compatible, 0, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_P_compatible_LEN 1
#define DT_N_S_sim_flash_S_flash_sim_0_P_compatible_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_P_reg {0 /* 0x0 */, 1048576 /* 0x100000 */}
#define DT_N_S_sim_flash_S_flash_sim_0_P_reg_IDX_0 0
#define DT_N_S_sim_flash_S_flash_sim_0_P_reg_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_P_reg_IDX_1 1048576
#define DT_N_S_sim_flash_S_flash_sim_0_P_reg_IDX_1_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0, reg, 0) \
	fn(DT_N_S_sim_flash_S_flash_sim_0, reg, 1)
#define DT_N_S_sim_flash_S_flash_sim_0_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0, reg, 1, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_P_reg_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_P_wakeup_source 0
#define DT_N_S_sim_flash_S_flash_sim_0_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /sim_flash/flash_sim@0/partitions
 *
 * Node identifier: DT_N_S_sim_flash_S_flash_sim_0_S_partitions
 *
 * Binding (compatible = fixed-partitions):
 *   $ZEPHYR_BASE/dts/bindings/mtd/partition.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_PATH "/sim_flash/flash_sim@0/partitions"

/* Node's name with unit-address: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_FULL_NAME "partitions"

/* Node parent (/sim_flash/flash_sim@0) identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_PARENT DT_N_S_sim_flash_S_flash_sim_0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_FOREACH_CHILD(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, __VA_ARGS__) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, __VA_ARGS__) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, __VA_ARGS__) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, __VA_ARGS__) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, __VA_ARGS__) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, __VA_ARGS__) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_ORD 6

/* Ordinals for what this node depends on directly: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_REQUIRES_ORDS \
	5, /* /sim_flash/flash_sim@0 */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_SUPPORTS_ORDS \
	7, /* /sim_flash/flash_sim@0/partitions/partition@31000 */ \
	13, /* /sim_flash/flash_sim@0/partitions/partition@1000 */ \
	14, /* /sim_flash/flash_sim@0/partitions/partition@11000 */ \
	15, /* /sim_flash/flash_sim@0/partitions/partition@21000 */

/* Existence and alternate IDs: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_EXISTS 1
#define DT_N_INST_0_fixed_partitions DT_N_S_sim_flash_S_flash_sim_0_S_partitions

/* Macros for properties that are special in the specification: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_REG_NUM 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_IRQ_NUM 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_COMPAT_MATCHES_fixed_partitions 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_PINCTRL_NUM 0

/* (No generic property macros) */

/*
 * Devicetree node: /sim_flash/flash_sim@0/partitions/partition@31000
 *
 * Node identifier: DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_PATH "/sim_flash/flash_sim@0/partitions/partition@31000"

/* Node's name with unit-address: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_FULL_NAME "partition@31000"

/* Node parent (/sim_flash/flash_sim@0/partitions) identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_PARENT DT_N_S_sim_flash_S_flash_sim_0_S_partitions
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_FOREACH_CHILD(fn) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_ORD 7

/* Ordinals for what this node depends on directly: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_REQUIRES_ORDS \
	6, /* /sim_flash/flash_sim@0/partitions */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_SUPPORTS_ORDS \
	8, /* /eeprom1 */

/* Existence and alternate IDs: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_EXISTS 1
#define DT_N_NODELABEL_eepromemu_partition DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000

/* Macros for properties that are special in the specification: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_REG_NUM 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_REG_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_REG_IDX_0_VAL_ADDRESS 200704 /* 0x31000 */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_REG_IDX_0_VAL_SIZE 65536 /* 0x10000 */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_IRQ_NUM 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_PINCTRL_NUM 0

/* fixed-partitions identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_PARTITION_ID 0

/* Generic property macros: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_label "eeprom-emu"
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_label_STRING_TOKEN eeprom_emu
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_label_STRING_UPPER_TOKEN EEPROM_EMU
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 0) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 1) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 2) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 3) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 4) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 5) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 6) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 7) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 8) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 9)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 3, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 4, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 5, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 6, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 7, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 8, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, label, 9, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_label_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_read_only 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_read_only_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_reg {200704 /* 0x31000 */, 65536 /* 0x10000 */}
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_reg_IDX_0 200704
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_reg_IDX_1 65536
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, reg, 0) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, reg, 1)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000, reg, 1, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000_P_reg_EXISTS 1

/*
 * Devicetree node: /eeprom1
 *
 * Node identifier: DT_N_S_eeprom1
 *
 * Binding (compatible = zephyr,emu-eeprom):
 *   $ZEPHYR_BASE/dts/bindings/mtd/zephyr,emu-eeprom.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_eeprom1_PATH "/eeprom1"

/* Node's name with unit-address: */
#define DT_N_S_eeprom1_FULL_NAME "eeprom1"

/* Node parent (/) identifier: */
#define DT_N_S_eeprom1_PARENT DT_N
#define DT_N_S_eeprom1_FOREACH_CHILD(fn) 
#define DT_N_S_eeprom1_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_eeprom1_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_eeprom1_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_eeprom1_ORD 8

/* Ordinals for what this node depends on directly: */
#define DT_N_S_eeprom1_REQUIRES_ORDS \
	0, /* / */ \
	7, /* /sim_flash/flash_sim@0/partitions/partition@31000 */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_eeprom1_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_eeprom1_EXISTS 1
#define DT_N_ALIAS_eeprom_1           DT_N_S_eeprom1
#define DT_N_INST_0_zephyr_emu_eeprom DT_N_S_eeprom1
#define DT_N_NODELABEL_eeprom1        DT_N_S_eeprom1

/* Macros for properties that are special in the specification: */
#define DT_N_S_eeprom1_REG_NUM 0
#define DT_N_S_eeprom1_IRQ_NUM 0
#define DT_N_S_eeprom1_COMPAT_MATCHES_zephyr_emu_eeprom 1
#define DT_N_S_eeprom1_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_eeprom1_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_eeprom1_P_size 4096
#define DT_N_S_eeprom1_P_size_EXISTS 1
#define DT_N_S_eeprom1_P_pagesize 8192
#define DT_N_S_eeprom1_P_pagesize_EXISTS 1
#define DT_N_S_eeprom1_P_partition DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000
#define DT_N_S_eeprom1_P_partition_IDX_0 DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000
#define DT_N_S_eeprom1_P_partition_IDX_0_PH DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000
#define DT_N_S_eeprom1_P_partition_IDX_0_EXISTS 1
#define DT_N_S_eeprom1_P_partition_LEN 1
#define DT_N_S_eeprom1_P_partition_EXISTS 1
#define DT_N_S_eeprom1_P_rambuf 1
#define DT_N_S_eeprom1_P_rambuf_EXISTS 1
#define DT_N_S_eeprom1_P_partition_erase 0
#define DT_N_S_eeprom1_P_partition_erase_EXISTS 1
#define DT_N_S_eeprom1_P_read_only 0
#define DT_N_S_eeprom1_P_read_only_EXISTS 1
#define DT_N_S_eeprom1_P_label "EEPROM_1"
#define DT_N_S_eeprom1_P_label_STRING_TOKEN EEPROM_1
#define DT_N_S_eeprom1_P_label_STRING_UPPER_TOKEN EEPROM_1
#define DT_N_S_eeprom1_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_eeprom1, label, 0) \
	fn(DT_N_S_eeprom1, label, 1) \
	fn(DT_N_S_eeprom1, label, 2) \
	fn(DT_N_S_eeprom1, label, 3) \
	fn(DT_N_S_eeprom1, label, 4) \
	fn(DT_N_S_eeprom1, label, 5) \
	fn(DT_N_S_eeprom1, label, 6) \
	fn(DT_N_S_eeprom1, label, 7)
#define DT_N_S_eeprom1_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_eeprom1, label, 0, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, label, 1, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, label, 2, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, label, 3, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, label, 4, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, label, 5, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, label, 6, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, label, 7, __VA_ARGS__)
#define DT_N_S_eeprom1_P_label_EXISTS 1
#define DT_N_S_eeprom1_P_status "okay"
#define DT_N_S_eeprom1_P_status_STRING_TOKEN okay
#define DT_N_S_eeprom1_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_eeprom1_P_status_ENUM_IDX 1
#define DT_N_S_eeprom1_P_status_ENUM_TOKEN okay
#define DT_N_S_eeprom1_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_eeprom1_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_eeprom1, status, 0) \
	fn(DT_N_S_eeprom1, status, 1) \
	fn(DT_N_S_eeprom1, status, 2) \
	fn(DT_N_S_eeprom1, status, 3)
#define DT_N_S_eeprom1_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_eeprom1, status, 0, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, status, 1, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, status, 2, __VA_ARGS__) \
	fn(DT_N_S_eeprom1, status, 3, __VA_ARGS__)
#define DT_N_S_eeprom1_P_status_EXISTS 1
#define DT_N_S_eeprom1_P_compatible {"zephyr,emu-eeprom"}
#define DT_N_S_eeprom1_P_compatible_IDX_0 "zephyr,emu-eeprom"
#define DT_N_S_eeprom1_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_eeprom1_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_eeprom1, compatible, 0)
#define DT_N_S_eeprom1_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_eeprom1, compatible, 0, __VA_ARGS__)
#define DT_N_S_eeprom1_P_compatible_LEN 1
#define DT_N_S_eeprom1_P_compatible_EXISTS 1
#define DT_N_S_eeprom1_P_wakeup_source 0
#define DT_N_S_eeprom1_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /flash@500000
 *
 * Node identifier: DT_N_S_flash_500000
 *
 * Binding (compatible = soc-nv-flash):
 *   $ZEPHYR_BASE/dts/bindings/mtd/soc-nv-flash.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_flash_500000_PATH "/flash@500000"

/* Node's name with unit-address: */
#define DT_N_S_flash_500000_FULL_NAME "flash@500000"

/* Node parent (/) identifier: */
#define DT_N_S_flash_500000_PARENT DT_N
#define DT_N_S_flash_500000_FOREACH_CHILD(fn) 
#define DT_N_S_flash_500000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_flash_500000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_flash_500000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_flash_500000_ORD 9

/* Ordinals for what this node depends on directly: */
#define DT_N_S_flash_500000_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_flash_500000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_flash_500000_EXISTS 1
#define DT_N_INST_0_soc_nv_flash DT_N_S_flash_500000
#define DT_N_NODELABEL_flash0    DT_N_S_flash_500000

/* Macros for properties that are special in the specification: */
#define DT_N_S_flash_500000_REG_NUM 1
#define DT_N_S_flash_500000_REG_IDX_0_EXISTS 1
#define DT_N_S_flash_500000_REG_IDX_0_VAL_ADDRESS 5242880 /* 0x500000 */
#define DT_N_S_flash_500000_REG_IDX_0_VAL_SIZE 4194304 /* 0x400000 */
#define DT_N_S_flash_500000_IRQ_NUM 0
#define DT_N_S_flash_500000_COMPAT_MATCHES_soc_nv_flash 1
#define DT_N_S_flash_500000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_flash_500000_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_flash_500000_P_compatible {"soc-nv-flash"}
#define DT_N_S_flash_500000_P_compatible_IDX_0 "soc-nv-flash"
#define DT_N_S_flash_500000_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_flash_500000_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_500000, compatible, 0)
#define DT_N_S_flash_500000_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_500000, compatible, 0, __VA_ARGS__)
#define DT_N_S_flash_500000_P_compatible_LEN 1
#define DT_N_S_flash_500000_P_compatible_EXISTS 1
#define DT_N_S_flash_500000_P_reg {5242880 /* 0x500000 */, 4194304 /* 0x400000 */}
#define DT_N_S_flash_500000_P_reg_IDX_0 5242880
#define DT_N_S_flash_500000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_flash_500000_P_reg_IDX_1 4194304
#define DT_N_S_flash_500000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_flash_500000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_500000, reg, 0) \
	fn(DT_N_S_flash_500000, reg, 1)
#define DT_N_S_flash_500000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_500000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_500000, reg, 1, __VA_ARGS__)
#define DT_N_S_flash_500000_P_reg_EXISTS 1
#define DT_N_S_flash_500000_P_wakeup_source 0
#define DT_N_S_flash_500000_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /memory@0
 *
 * Node identifier: DT_N_S_memory_0
 */

/* Node's full path: */
#define DT_N_S_memory_0_PATH "/memory@0"

/* Node's name with unit-address: */
#define DT_N_S_memory_0_FULL_NAME "memory@0"

/* Node parent (/) identifier: */
#define DT_N_S_memory_0_PARENT DT_N
#define DT_N_S_memory_0_FOREACH_CHILD(fn) 
#define DT_N_S_memory_0_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_memory_0_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_memory_0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_memory_0_ORD 10

/* Ordinals for what this node depends on directly: */
#define DT_N_S_memory_0_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_memory_0_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_memory_0_EXISTS 1
#define DT_N_NODELABEL_dram0 DT_N_S_memory_0

/* Macros for properties that are special in the specification: */
#define DT_N_S_memory_0_REG_NUM 1
#define DT_N_S_memory_0_REG_IDX_0_EXISTS 1
#define DT_N_S_memory_0_REG_IDX_0_VAL_ADDRESS 0 /* 0x0 */
#define DT_N_S_memory_0_REG_IDX_0_VAL_SIZE 4194304 /* 0x400000 */
#define DT_N_S_memory_0_IRQ_NUM 0
#define DT_N_S_memory_0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_memory_0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_memory_0_P_reg {0 /* 0x0 */, 4194304 /* 0x400000 */}
#define DT_N_S_memory_0_P_reg_IDX_0 0
#define DT_N_S_memory_0_P_reg_IDX_0_EXISTS 1
#define DT_N_S_memory_0_P_reg_IDX_1 4194304
#define DT_N_S_memory_0_P_reg_IDX_1_EXISTS 1
#define DT_N_S_memory_0_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_memory_0, reg, 0) \
	fn(DT_N_S_memory_0, reg, 1)
#define DT_N_S_memory_0_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_memory_0, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_memory_0, reg, 1, __VA_ARGS__)
#define DT_N_S_memory_0_P_reg_EXISTS 1

/*
 * Devicetree node: /cpus
 *
 * Node identifier: DT_N_S_cpus
 */

/* Node's full path: */
#define DT_N_S_cpus_PATH "/cpus"

/* Node's name with unit-address: */
#define DT_N_S_cpus_FULL_NAME "cpus"

/* Node parent (/) identifier: */
#define DT_N_S_cpus_PARENT DT_N
#define DT_N_S_cpus_FOREACH_CHILD(fn) fn(DT_N_S_cpus_S_cpu_0)
#define DT_N_S_cpus_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_cpus_S_cpu_0, __VA_ARGS__)
#define DT_N_S_cpus_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_cpus_S_cpu_0) 
#define DT_N_S_cpus_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_cpus_S_cpu_0, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_cpus_ORD 11

/* Ordinals for what this node depends on directly: */
#define DT_N_S_cpus_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_cpus_SUPPORTS_ORDS \
	12, /* /cpus/cpu@0 */

/* Existence and alternate IDs: */
#define DT_N_S_cpus_EXISTS 1

/* Macros for properties that are special in the specification: */
#define DT_N_S_cpus_REG_NUM 0
#define DT_N_S_cpus_IRQ_NUM 0
#define DT_N_S_cpus_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_cpus_PINCTRL_NUM 0

/* (No generic property macros) */

/*
 * Devicetree node: /cpus/cpu@0
 *
 * Node identifier: DT_N_S_cpus_S_cpu_0
 *
 * Binding (compatible = intel,x86):
 *   $ZEPHYR_BASE/dts/bindings/cpu/intel,x86.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_cpus_S_cpu_0_PATH "/cpus/cpu@0"

/* Node's name with unit-address: */
#define DT_N_S_cpus_S_cpu_0_FULL_NAME "cpu@0"

/* Node parent (/cpus) identifier: */
#define DT_N_S_cpus_S_cpu_0_PARENT DT_N_S_cpus
#define DT_N_S_cpus_S_cpu_0_FOREACH_CHILD(fn) 
#define DT_N_S_cpus_S_cpu_0_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_cpus_S_cpu_0_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_cpus_S_cpu_0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_cpus_S_cpu_0_ORD 12

/* Ordinals for what this node depends on directly: */
#define DT_N_S_cpus_S_cpu_0_REQUIRES_ORDS \
	11, /* /cpus */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_cpus_S_cpu_0_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_cpus_S_cpu_0_EXISTS 1
#define DT_N_INST_0_intel_x86 DT_N_S_cpus_S_cpu_0

/* Macros for properties that are special in the specification: */
#define DT_N_S_cpus_S_cpu_0_REG_NUM 1
#define DT_N_S_cpus_S_cpu_0_REG_IDX_0_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_REG_IDX_0_VAL_ADDRESS 0 /* 0x0 */
#define DT_N_S_cpus_S_cpu_0_IRQ_NUM 0
#define DT_N_S_cpus_S_cpu_0_COMPAT_MATCHES_intel_x86 1
#define DT_N_S_cpus_S_cpu_0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_cpus_S_cpu_0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_cpus_S_cpu_0_P_d_cache_line_size 64
#define DT_N_S_cpus_S_cpu_0_P_d_cache_line_size_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_P_compatible {"intel,x86"}
#define DT_N_S_cpus_S_cpu_0_P_compatible_IDX_0 "intel,x86"
#define DT_N_S_cpus_S_cpu_0_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_cpus_S_cpu_0, compatible, 0)
#define DT_N_S_cpus_S_cpu_0_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_cpus_S_cpu_0, compatible, 0, __VA_ARGS__)
#define DT_N_S_cpus_S_cpu_0_P_compatible_LEN 1
#define DT_N_S_cpus_S_cpu_0_P_compatible_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_P_reg {0 /* 0x0 */}
#define DT_N_S_cpus_S_cpu_0_P_reg_IDX_0 0
#define DT_N_S_cpus_S_cpu_0_P_reg_IDX_0_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_cpus_S_cpu_0, reg, 0)
#define DT_N_S_cpus_S_cpu_0_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_cpus_S_cpu_0, reg, 0, __VA_ARGS__)
#define DT_N_S_cpus_S_cpu_0_P_reg_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_P_wakeup_source 0
#define DT_N_S_cpus_S_cpu_0_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /sim_flash/flash_sim@0/partitions/partition@1000
 *
 * Node identifier: DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_PATH "/sim_flash/flash_sim@0/partitions/partition@1000"

/* Node's name with unit-address: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_FULL_NAME "partition@1000"

/* Node parent (/sim_flash/flash_sim@0/partitions) identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_PARENT DT_N_S_sim_flash_S_flash_sim_0_S_partitions
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_FOREACH_CHILD(fn) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_ORD 13

/* Ordinals for what this node depends on directly: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_REQUIRES_ORDS \
	6, /* /sim_flash/flash_sim@0/partitions */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_EXISTS 1
#define DT_N_NODELABEL_storage_partition DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000

/* Macros for properties that are special in the specification: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_REG_NUM 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_REG_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_REG_IDX_0_VAL_ADDRESS 4096 /* 0x1000 */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_REG_IDX_0_VAL_SIZE 65536 /* 0x10000 */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_IRQ_NUM 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_PINCTRL_NUM 0

/* fixed-partitions identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_PARTITION_ID 1

/* Generic property macros: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_label "storage"
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_label_STRING_TOKEN storage
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_label_STRING_UPPER_TOKEN STORAGE
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 0) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 1) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 2) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 3) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 4) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 5) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 6)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 3, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 4, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 5, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, label, 6, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_label_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_read_only 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_read_only_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_reg {4096 /* 0x1000 */, 65536 /* 0x10000 */}
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_reg_IDX_0 4096
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_reg_IDX_1 65536
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, reg, 0) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, reg, 1)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000, reg, 1, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000_P_reg_EXISTS 1

/*
 * Devicetree node: /sim_flash/flash_sim@0/partitions/partition@11000
 *
 * Node identifier: DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_PATH "/sim_flash/flash_sim@0/partitions/partition@11000"

/* Node's name with unit-address: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_FULL_NAME "partition@11000"

/* Node parent (/sim_flash/flash_sim@0/partitions) identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_PARENT DT_N_S_sim_flash_S_flash_sim_0_S_partitions
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_FOREACH_CHILD(fn) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_ORD 14

/* Ordinals for what this node depends on directly: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_REQUIRES_ORDS \
	6, /* /sim_flash/flash_sim@0/partitions */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_EXISTS 1
#define DT_N_NODELABEL_slot0_partition DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000

/* Macros for properties that are special in the specification: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_REG_NUM 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_REG_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_REG_IDX_0_VAL_ADDRESS 69632 /* 0x11000 */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_REG_IDX_0_VAL_SIZE 65536 /* 0x10000 */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_IRQ_NUM 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_PINCTRL_NUM 0

/* fixed-partitions identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_PARTITION_ID 2

/* Generic property macros: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_label "image-0"
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_label_STRING_TOKEN image_0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_label_STRING_UPPER_TOKEN IMAGE_0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 0) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 1) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 2) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 3) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 4) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 5) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 6)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 3, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 4, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 5, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, label, 6, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_label_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_read_only 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_read_only_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_reg {69632 /* 0x11000 */, 65536 /* 0x10000 */}
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_reg_IDX_0 69632
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_reg_IDX_1 65536
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, reg, 0) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, reg, 1)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000, reg, 1, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000_P_reg_EXISTS 1

/*
 * Devicetree node: /sim_flash/flash_sim@0/partitions/partition@21000
 *
 * Node identifier: DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_PATH "/sim_flash/flash_sim@0/partitions/partition@21000"

/* Node's name with unit-address: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_FULL_NAME "partition@21000"

/* Node parent (/sim_flash/flash_sim@0/partitions) identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_PARENT DT_N_S_sim_flash_S_flash_sim_0_S_partitions
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_FOREACH_CHILD(fn) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_ORD 15

/* Ordinals for what this node depends on directly: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_REQUIRES_ORDS \
	6, /* /sim_flash/flash_sim@0/partitions */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_EXISTS 1
#define DT_N_NODELABEL_slot1_partition DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000

/* Macros for properties that are special in the specification: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_REG_NUM 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_REG_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_REG_IDX_0_VAL_ADDRESS 135168 /* 0x21000 */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_REG_IDX_0_VAL_SIZE 65536 /* 0x10000 */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_IRQ_NUM 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_PINCTRL_NUM 0

/* fixed-partitions identifier: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_PARTITION_ID 3

/* Generic property macros: */
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_label "image-1"
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_label_STRING_TOKEN image_1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_label_STRING_UPPER_TOKEN IMAGE_1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 0) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 1) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 2) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 3) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 4) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 5) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 6)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 3, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 4, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 5, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, label, 6, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_label_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_read_only 0
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_read_only_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_reg {135168 /* 0x21000 */, 65536 /* 0x10000 */}
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_reg_IDX_0 135168
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_reg_IDX_1 65536
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, reg, 0) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, reg, 1)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000, reg, 1, __VA_ARGS__)
#define DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000_P_reg_EXISTS 1

/*
 * Devicetree node: /ioapic@fec00000
 *
 * Node identifier: DT_N_S_ioapic_fec00000
 *
 * Binding (compatible = intel,ioapic):
 *   $ZEPHYR_BASE/dts/bindings/interrupt-controller/intel,ioapic.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_ioapic_fec00000_PATH "/ioapic@fec00000"

/* Node's name with unit-address: */
#define DT_N_S_ioapic_fec00000_FULL_NAME "ioapic@fec00000"

/* Node parent (/) identifier: */
#define DT_N_S_ioapic_fec00000_PARENT DT_N
#define DT_N_S_ioapic_fec00000_FOREACH_CHILD(fn) 
#define DT_N_S_ioapic_fec00000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_ioapic_fec00000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_ioapic_fec00000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_ioapic_fec00000_ORD 16

/* Ordinals for what this node depends on directly: */
#define DT_N_S_ioapic_fec00000_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_ioapic_fec00000_SUPPORTS_ORDS \
	18, /* /soc/eth@febc0000 */ \
	19, /* /soc/hpet@fed00000 */ \
	20, /* /soc/uart@2f8 */ \
	21, /* /soc/uart@3f8 */

/* Existence and alternate IDs: */
#define DT_N_S_ioapic_fec00000_EXISTS 1
#define DT_N_INST_0_intel_ioapic DT_N_S_ioapic_fec00000
#define DT_N_NODELABEL_intc      DT_N_S_ioapic_fec00000

/* Macros for properties that are special in the specification: */
#define DT_N_S_ioapic_fec00000_REG_NUM 1
#define DT_N_S_ioapic_fec00000_REG_IDX_0_EXISTS 1
#define DT_N_S_ioapic_fec00000_REG_IDX_0_VAL_ADDRESS 4273995776 /* 0xfec00000 */
#define DT_N_S_ioapic_fec00000_REG_IDX_0_VAL_SIZE 4096 /* 0x1000 */
#define DT_N_S_ioapic_fec00000_IRQ_NUM 0
#define DT_N_S_ioapic_fec00000_COMPAT_MATCHES_intel_ioapic 1
#define DT_N_S_ioapic_fec00000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_ioapic_fec00000_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_ioapic_fec00000_P_reg {4273995776 /* 0xfec00000 */, 4096 /* 0x1000 */}
#define DT_N_S_ioapic_fec00000_P_reg_IDX_0 4273995776
#define DT_N_S_ioapic_fec00000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_ioapic_fec00000_P_reg_IDX_1 4096
#define DT_N_S_ioapic_fec00000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_ioapic_fec00000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_ioapic_fec00000, reg, 0) \
	fn(DT_N_S_ioapic_fec00000, reg, 1)
#define DT_N_S_ioapic_fec00000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_ioapic_fec00000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_ioapic_fec00000, reg, 1, __VA_ARGS__)
#define DT_N_S_ioapic_fec00000_P_reg_EXISTS 1
#define DT_N_S_ioapic_fec00000_P_interrupt_controller 1
#define DT_N_S_ioapic_fec00000_P_interrupt_controller_EXISTS 1
#define DT_N_S_ioapic_fec00000_P_compatible {"intel,ioapic"}
#define DT_N_S_ioapic_fec00000_P_compatible_IDX_0 "intel,ioapic"
#define DT_N_S_ioapic_fec00000_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_ioapic_fec00000_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_ioapic_fec00000, compatible, 0)
#define DT_N_S_ioapic_fec00000_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_ioapic_fec00000, compatible, 0, __VA_ARGS__)
#define DT_N_S_ioapic_fec00000_P_compatible_LEN 1
#define DT_N_S_ioapic_fec00000_P_compatible_EXISTS 1
#define DT_N_S_ioapic_fec00000_P_wakeup_source 0
#define DT_N_S_ioapic_fec00000_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /soc
 *
 * Node identifier: DT_N_S_soc
 */

/* Node's full path: */
#define DT_N_S_soc_PATH "/soc"

/* Node's name with unit-address: */
#define DT_N_S_soc_FULL_NAME "soc"

/* Node parent (/) identifier: */
#define DT_N_S_soc_PARENT DT_N
#define DT_N_S_soc_FOREACH_CHILD(fn) fn(DT_N_S_soc_S_uart_3f8) fn(DT_N_S_soc_S_uart_2f8) fn(DT_N_S_soc_S_hpet_fed00000) fn(DT_N_S_soc_S_eth_febc0000)
#define DT_N_S_soc_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_3f8, __VA_ARGS__) fn(DT_N_S_soc_S_uart_2f8, __VA_ARGS__) fn(DT_N_S_soc_S_hpet_fed00000, __VA_ARGS__) fn(DT_N_S_soc_S_eth_febc0000, __VA_ARGS__)
#define DT_N_S_soc_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_soc_S_uart_3f8) fn(DT_N_S_soc_S_uart_2f8) fn(DT_N_S_soc_S_hpet_fed00000) fn(DT_N_S_soc_S_eth_febc0000) 
#define DT_N_S_soc_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_3f8, __VA_ARGS__) fn(DT_N_S_soc_S_uart_2f8, __VA_ARGS__) fn(DT_N_S_soc_S_hpet_fed00000, __VA_ARGS__) fn(DT_N_S_soc_S_eth_febc0000, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_soc_ORD 17

/* Ordinals for what this node depends on directly: */
#define DT_N_S_soc_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_soc_SUPPORTS_ORDS \
	18, /* /soc/eth@febc0000 */ \
	19, /* /soc/hpet@fed00000 */ \
	20, /* /soc/uart@2f8 */ \
	21, /* /soc/uart@3f8 */

/* Existence and alternate IDs: */
#define DT_N_S_soc_EXISTS 1
#define DT_N_INST_0_simple_bus DT_N_S_soc

/* Macros for properties that are special in the specification: */
#define DT_N_S_soc_REG_NUM 0
#define DT_N_S_soc_IRQ_NUM 0
#define DT_N_S_soc_COMPAT_MATCHES_simple_bus 1
#define DT_N_S_soc_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_soc_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_soc_P_compatible {"simple-bus"}
#define DT_N_S_soc_P_compatible_IDX_0 "simple-bus"
#define DT_N_S_soc_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_soc_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc, compatible, 0)
#define DT_N_S_soc_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc, compatible, 0, __VA_ARGS__)
#define DT_N_S_soc_P_compatible_LEN 1
#define DT_N_S_soc_P_compatible_EXISTS 1

/*
 * Devicetree node: /soc/eth@febc0000
 *
 * Node identifier: DT_N_S_soc_S_eth_febc0000
 *
 * Binding (compatible = intel,e1000):
 *   $ZEPHYR_BASE/dts/bindings/ethernet/intel,e1000.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_soc_S_eth_febc0000_PATH "/soc/eth@febc0000"

/* Node's name with unit-address: */
#define DT_N_S_soc_S_eth_febc0000_FULL_NAME "eth@febc0000"

/* Node parent (/soc) identifier: */
#define DT_N_S_soc_S_eth_febc0000_PARENT DT_N_S_soc
#define DT_N_S_soc_S_eth_febc0000_FOREACH_CHILD(fn) 
#define DT_N_S_soc_S_eth_febc0000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_soc_S_eth_febc0000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_soc_S_eth_febc0000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_soc_S_eth_febc0000_ORD 18

/* Ordinals for what this node depends on directly: */
#define DT_N_S_soc_S_eth_febc0000_REQUIRES_ORDS \
	16, /* /ioapic@fec00000 */ \
	17, /* /soc */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_soc_S_eth_febc0000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_soc_S_eth_febc0000_EXISTS 1
#define DT_N_INST_0_intel_e1000 DT_N_S_soc_S_eth_febc0000
#define DT_N_NODELABEL_eth0     DT_N_S_soc_S_eth_febc0000

/* Macros for properties that are special in the specification: */
#define DT_N_S_soc_S_eth_febc0000_REG_NUM 1
#define DT_N_S_soc_S_eth_febc0000_REG_IDX_0_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_REG_IDX_0_VAL_ADDRESS 4273733632 /* 0xfebc0000 */
#define DT_N_S_soc_S_eth_febc0000_REG_IDX_0_VAL_SIZE 256 /* 0x100 */
#define DT_N_S_soc_S_eth_febc0000_IRQ_NUM 1
#define DT_N_S_soc_S_eth_febc0000_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_IRQ_IDX_0_VAL_irq 11
#define DT_N_S_soc_S_eth_febc0000_IRQ_IDX_0_VAL_irq_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_IRQ_IDX_0_VAL_sense 256
#define DT_N_S_soc_S_eth_febc0000_IRQ_IDX_0_VAL_sense_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_IRQ_IDX_0_VAL_priority 3
#define DT_N_S_soc_S_eth_febc0000_IRQ_IDX_0_VAL_priority_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_COMPAT_MATCHES_intel_e1000 1
#define DT_N_S_soc_S_eth_febc0000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_soc_S_eth_febc0000_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_soc_S_eth_febc0000_P_reg {4273733632 /* 0xfebc0000 */, 256 /* 0x100 */}
#define DT_N_S_soc_S_eth_febc0000_P_reg_IDX_0 4273733632
#define DT_N_S_soc_S_eth_febc0000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_reg_IDX_1 256
#define DT_N_S_soc_S_eth_febc0000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_eth_febc0000, reg, 0) \
	fn(DT_N_S_soc_S_eth_febc0000, reg, 1)
#define DT_N_S_soc_S_eth_febc0000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_eth_febc0000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_eth_febc0000, reg, 1, __VA_ARGS__)
#define DT_N_S_soc_S_eth_febc0000_P_reg_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_interrupts {11 /* 0xb */, 256 /* 0x100 */, 3 /* 0x3 */}
#define DT_N_S_soc_S_eth_febc0000_P_interrupts_IDX_0 11
#define DT_N_S_soc_S_eth_febc0000_P_interrupts_IDX_0_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_interrupts_IDX_1 256
#define DT_N_S_soc_S_eth_febc0000_P_interrupts_IDX_1_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_interrupts_IDX_2 3
#define DT_N_S_soc_S_eth_febc0000_P_interrupts_IDX_2_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_interrupts_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_eth_febc0000, interrupts, 0) \
	fn(DT_N_S_soc_S_eth_febc0000, interrupts, 1) \
	fn(DT_N_S_soc_S_eth_febc0000, interrupts, 2)
#define DT_N_S_soc_S_eth_febc0000_P_interrupts_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_eth_febc0000, interrupts, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_eth_febc0000, interrupts, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_eth_febc0000, interrupts, 2, __VA_ARGS__)
#define DT_N_S_soc_S_eth_febc0000_P_interrupts_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_status "okay"
#define DT_N_S_soc_S_eth_febc0000_P_status_STRING_TOKEN okay
#define DT_N_S_soc_S_eth_febc0000_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_soc_S_eth_febc0000_P_status_ENUM_IDX 1
#define DT_N_S_soc_S_eth_febc0000_P_status_ENUM_TOKEN okay
#define DT_N_S_soc_S_eth_febc0000_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_soc_S_eth_febc0000_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_eth_febc0000, status, 0) \
	fn(DT_N_S_soc_S_eth_febc0000, status, 1) \
	fn(DT_N_S_soc_S_eth_febc0000, status, 2) \
	fn(DT_N_S_soc_S_eth_febc0000, status, 3)
#define DT_N_S_soc_S_eth_febc0000_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_eth_febc0000, status, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_eth_febc0000, status, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_eth_febc0000, status, 2, __VA_ARGS__) \
	fn(DT_N_S_soc_S_eth_febc0000, status, 3, __VA_ARGS__)
#define DT_N_S_soc_S_eth_febc0000_P_status_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_compatible {"intel,e1000"}
#define DT_N_S_soc_S_eth_febc0000_P_compatible_IDX_0 "intel,e1000"
#define DT_N_S_soc_S_eth_febc0000_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_eth_febc0000, compatible, 0)
#define DT_N_S_soc_S_eth_febc0000_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_eth_febc0000, compatible, 0, __VA_ARGS__)
#define DT_N_S_soc_S_eth_febc0000_P_compatible_LEN 1
#define DT_N_S_soc_S_eth_febc0000_P_compatible_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_interrupt_parent DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_eth_febc0000_P_interrupt_parent_IDX_0 DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_eth_febc0000_P_interrupt_parent_IDX_0_PH DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_eth_febc0000_P_interrupt_parent_IDX_0_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_interrupt_parent_LEN 1
#define DT_N_S_soc_S_eth_febc0000_P_interrupt_parent_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_label "eth0"
#define DT_N_S_soc_S_eth_febc0000_P_label_STRING_TOKEN eth0
#define DT_N_S_soc_S_eth_febc0000_P_label_STRING_UPPER_TOKEN ETH0
#define DT_N_S_soc_S_eth_febc0000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_eth_febc0000, label, 0) \
	fn(DT_N_S_soc_S_eth_febc0000, label, 1) \
	fn(DT_N_S_soc_S_eth_febc0000, label, 2) \
	fn(DT_N_S_soc_S_eth_febc0000, label, 3)
#define DT_N_S_soc_S_eth_febc0000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_eth_febc0000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_eth_febc0000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_eth_febc0000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_soc_S_eth_febc0000, label, 3, __VA_ARGS__)
#define DT_N_S_soc_S_eth_febc0000_P_label_EXISTS 1
#define DT_N_S_soc_S_eth_febc0000_P_wakeup_source 0
#define DT_N_S_soc_S_eth_febc0000_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /soc/hpet@fed00000
 *
 * Node identifier: DT_N_S_soc_S_hpet_fed00000
 *
 * Binding (compatible = intel,hpet):
 *   $ZEPHYR_BASE/dts/bindings/timer/intel,hpet.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_soc_S_hpet_fed00000_PATH "/soc/hpet@fed00000"

/* Node's name with unit-address: */
#define DT_N_S_soc_S_hpet_fed00000_FULL_NAME "hpet@fed00000"

/* Node parent (/soc) identifier: */
#define DT_N_S_soc_S_hpet_fed00000_PARENT DT_N_S_soc
#define DT_N_S_soc_S_hpet_fed00000_FOREACH_CHILD(fn) 
#define DT_N_S_soc_S_hpet_fed00000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_soc_S_hpet_fed00000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_soc_S_hpet_fed00000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_soc_S_hpet_fed00000_ORD 19

/* Ordinals for what this node depends on directly: */
#define DT_N_S_soc_S_hpet_fed00000_REQUIRES_ORDS \
	16, /* /ioapic@fec00000 */ \
	17, /* /soc */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_soc_S_hpet_fed00000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_soc_S_hpet_fed00000_EXISTS 1
#define DT_N_INST_0_intel_hpet DT_N_S_soc_S_hpet_fed00000
#define DT_N_NODELABEL_hpet    DT_N_S_soc_S_hpet_fed00000

/* Macros for properties that are special in the specification: */
#define DT_N_S_soc_S_hpet_fed00000_REG_NUM 1
#define DT_N_S_soc_S_hpet_fed00000_REG_IDX_0_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_REG_IDX_0_VAL_ADDRESS 4275044352 /* 0xfed00000 */
#define DT_N_S_soc_S_hpet_fed00000_REG_IDX_0_VAL_SIZE 1024 /* 0x400 */
#define DT_N_S_soc_S_hpet_fed00000_IRQ_NUM 1
#define DT_N_S_soc_S_hpet_fed00000_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_IRQ_IDX_0_VAL_irq 2
#define DT_N_S_soc_S_hpet_fed00000_IRQ_IDX_0_VAL_irq_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_IRQ_IDX_0_VAL_sense 0
#define DT_N_S_soc_S_hpet_fed00000_IRQ_IDX_0_VAL_sense_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_IRQ_IDX_0_VAL_priority 4
#define DT_N_S_soc_S_hpet_fed00000_IRQ_IDX_0_VAL_priority_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_COMPAT_MATCHES_intel_hpet 1
#define DT_N_S_soc_S_hpet_fed00000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_soc_S_hpet_fed00000_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_soc_S_hpet_fed00000_P_reg {4275044352 /* 0xfed00000 */, 1024 /* 0x400 */}
#define DT_N_S_soc_S_hpet_fed00000_P_reg_IDX_0 4275044352
#define DT_N_S_soc_S_hpet_fed00000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_reg_IDX_1 1024
#define DT_N_S_soc_S_hpet_fed00000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_hpet_fed00000, reg, 0) \
	fn(DT_N_S_soc_S_hpet_fed00000, reg, 1)
#define DT_N_S_soc_S_hpet_fed00000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_hpet_fed00000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_hpet_fed00000, reg, 1, __VA_ARGS__)
#define DT_N_S_soc_S_hpet_fed00000_P_reg_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts {2 /* 0x2 */, 0 /* 0x0 */, 4 /* 0x4 */}
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts_IDX_0 2
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts_IDX_0_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts_IDX_1 0
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts_IDX_1_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts_IDX_2 4
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts_IDX_2_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_hpet_fed00000, interrupts, 0) \
	fn(DT_N_S_soc_S_hpet_fed00000, interrupts, 1) \
	fn(DT_N_S_soc_S_hpet_fed00000, interrupts, 2)
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_hpet_fed00000, interrupts, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_hpet_fed00000, interrupts, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_hpet_fed00000, interrupts, 2, __VA_ARGS__)
#define DT_N_S_soc_S_hpet_fed00000_P_interrupts_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_status "okay"
#define DT_N_S_soc_S_hpet_fed00000_P_status_STRING_TOKEN okay
#define DT_N_S_soc_S_hpet_fed00000_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_soc_S_hpet_fed00000_P_status_ENUM_IDX 1
#define DT_N_S_soc_S_hpet_fed00000_P_status_ENUM_TOKEN okay
#define DT_N_S_soc_S_hpet_fed00000_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_soc_S_hpet_fed00000_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_hpet_fed00000, status, 0) \
	fn(DT_N_S_soc_S_hpet_fed00000, status, 1) \
	fn(DT_N_S_soc_S_hpet_fed00000, status, 2) \
	fn(DT_N_S_soc_S_hpet_fed00000, status, 3)
#define DT_N_S_soc_S_hpet_fed00000_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_hpet_fed00000, status, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_hpet_fed00000, status, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_hpet_fed00000, status, 2, __VA_ARGS__) \
	fn(DT_N_S_soc_S_hpet_fed00000, status, 3, __VA_ARGS__)
#define DT_N_S_soc_S_hpet_fed00000_P_status_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_compatible {"intel,hpet"}
#define DT_N_S_soc_S_hpet_fed00000_P_compatible_IDX_0 "intel,hpet"
#define DT_N_S_soc_S_hpet_fed00000_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_hpet_fed00000, compatible, 0)
#define DT_N_S_soc_S_hpet_fed00000_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_hpet_fed00000, compatible, 0, __VA_ARGS__)
#define DT_N_S_soc_S_hpet_fed00000_P_compatible_LEN 1
#define DT_N_S_soc_S_hpet_fed00000_P_compatible_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_interrupt_parent DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_hpet_fed00000_P_interrupt_parent_IDX_0 DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_hpet_fed00000_P_interrupt_parent_IDX_0_PH DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_hpet_fed00000_P_interrupt_parent_IDX_0_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_interrupt_parent_LEN 1
#define DT_N_S_soc_S_hpet_fed00000_P_interrupt_parent_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_label "HPET"
#define DT_N_S_soc_S_hpet_fed00000_P_label_STRING_TOKEN HPET
#define DT_N_S_soc_S_hpet_fed00000_P_label_STRING_UPPER_TOKEN HPET
#define DT_N_S_soc_S_hpet_fed00000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_hpet_fed00000, label, 0) \
	fn(DT_N_S_soc_S_hpet_fed00000, label, 1) \
	fn(DT_N_S_soc_S_hpet_fed00000, label, 2) \
	fn(DT_N_S_soc_S_hpet_fed00000, label, 3)
#define DT_N_S_soc_S_hpet_fed00000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_hpet_fed00000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_hpet_fed00000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_hpet_fed00000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_soc_S_hpet_fed00000, label, 3, __VA_ARGS__)
#define DT_N_S_soc_S_hpet_fed00000_P_label_EXISTS 1
#define DT_N_S_soc_S_hpet_fed00000_P_wakeup_source 0
#define DT_N_S_soc_S_hpet_fed00000_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /soc/uart@2f8
 *
 * Node identifier: DT_N_S_soc_S_uart_2f8
 *
 * Binding (compatible = ns16550):
 *   $ZEPHYR_BASE/dts/bindings/serial/ns16550.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_soc_S_uart_2f8_PATH "/soc/uart@2f8"

/* Node's name with unit-address: */
#define DT_N_S_soc_S_uart_2f8_FULL_NAME "uart@2f8"

/* Node parent (/soc) identifier: */
#define DT_N_S_soc_S_uart_2f8_PARENT DT_N_S_soc
#define DT_N_S_soc_S_uart_2f8_FOREACH_CHILD(fn) 
#define DT_N_S_soc_S_uart_2f8_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_soc_S_uart_2f8_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_soc_S_uart_2f8_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_soc_S_uart_2f8_ORD 20

/* Ordinals for what this node depends on directly: */
#define DT_N_S_soc_S_uart_2f8_REQUIRES_ORDS \
	16, /* /ioapic@fec00000 */ \
	17, /* /soc */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_soc_S_uart_2f8_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_soc_S_uart_2f8_EXISTS 1
#define DT_N_ALIAS_uart_1    DT_N_S_soc_S_uart_2f8
#define DT_N_INST_1_ns16550  DT_N_S_soc_S_uart_2f8
#define DT_N_NODELABEL_uart1 DT_N_S_soc_S_uart_2f8

/* Macros for properties that are special in the specification: */
#define DT_N_S_soc_S_uart_2f8_REG_NUM 1
#define DT_N_S_soc_S_uart_2f8_REG_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_REG_IDX_0_VAL_ADDRESS 760 /* 0x2f8 */
#define DT_N_S_soc_S_uart_2f8_REG_IDX_0_VAL_SIZE 256 /* 0x100 */
#define DT_N_S_soc_S_uart_2f8_IRQ_NUM 1
#define DT_N_S_soc_S_uart_2f8_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_IRQ_IDX_0_VAL_irq 3
#define DT_N_S_soc_S_uart_2f8_IRQ_IDX_0_VAL_irq_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_IRQ_IDX_0_VAL_sense 256
#define DT_N_S_soc_S_uart_2f8_IRQ_IDX_0_VAL_sense_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_IRQ_IDX_0_VAL_priority 3
#define DT_N_S_soc_S_uart_2f8_IRQ_IDX_0_VAL_priority_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_COMPAT_MATCHES_ns16550 1
#define DT_N_S_soc_S_uart_2f8_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_soc_S_uart_2f8_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_soc_S_uart_2f8_P_reg {760 /* 0x2f8 */, 256 /* 0x100 */}
#define DT_N_S_soc_S_uart_2f8_P_reg_IDX_0 760
#define DT_N_S_soc_S_uart_2f8_P_reg_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_reg_IDX_1 256
#define DT_N_S_soc_S_uart_2f8_P_reg_IDX_1_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_2f8, reg, 0) \
	fn(DT_N_S_soc_S_uart_2f8, reg, 1)
#define DT_N_S_soc_S_uart_2f8_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_2f8, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, reg, 1, __VA_ARGS__)
#define DT_N_S_soc_S_uart_2f8_P_reg_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_clock_frequency 1843200
#define DT_N_S_soc_S_uart_2f8_P_clock_frequency_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_current_speed 115200
#define DT_N_S_soc_S_uart_2f8_P_current_speed_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_label "UART_1"
#define DT_N_S_soc_S_uart_2f8_P_label_STRING_TOKEN UART_1
#define DT_N_S_soc_S_uart_2f8_P_label_STRING_UPPER_TOKEN UART_1
#define DT_N_S_soc_S_uart_2f8_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_2f8, label, 0) \
	fn(DT_N_S_soc_S_uart_2f8, label, 1) \
	fn(DT_N_S_soc_S_uart_2f8, label, 2) \
	fn(DT_N_S_soc_S_uart_2f8, label, 3) \
	fn(DT_N_S_soc_S_uart_2f8, label, 4) \
	fn(DT_N_S_soc_S_uart_2f8, label, 5)
#define DT_N_S_soc_S_uart_2f8_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_2f8, label, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, label, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, label, 2, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, label, 3, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, label, 4, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, label, 5, __VA_ARGS__)
#define DT_N_S_soc_S_uart_2f8_P_label_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_hw_flow_control 0
#define DT_N_S_soc_S_uart_2f8_P_hw_flow_control_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_status "okay"
#define DT_N_S_soc_S_uart_2f8_P_status_STRING_TOKEN okay
#define DT_N_S_soc_S_uart_2f8_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_soc_S_uart_2f8_P_status_ENUM_IDX 1
#define DT_N_S_soc_S_uart_2f8_P_status_ENUM_TOKEN okay
#define DT_N_S_soc_S_uart_2f8_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_soc_S_uart_2f8_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_2f8, status, 0) \
	fn(DT_N_S_soc_S_uart_2f8, status, 1) \
	fn(DT_N_S_soc_S_uart_2f8, status, 2) \
	fn(DT_N_S_soc_S_uart_2f8, status, 3)
#define DT_N_S_soc_S_uart_2f8_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_2f8, status, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, status, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, status, 2, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, status, 3, __VA_ARGS__)
#define DT_N_S_soc_S_uart_2f8_P_status_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_compatible {"ns16550"}
#define DT_N_S_soc_S_uart_2f8_P_compatible_IDX_0 "ns16550"
#define DT_N_S_soc_S_uart_2f8_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_2f8, compatible, 0)
#define DT_N_S_soc_S_uart_2f8_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_2f8, compatible, 0, __VA_ARGS__)
#define DT_N_S_soc_S_uart_2f8_P_compatible_LEN 1
#define DT_N_S_soc_S_uart_2f8_P_compatible_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_interrupts {3 /* 0x3 */, 256 /* 0x100 */, 3 /* 0x3 */}
#define DT_N_S_soc_S_uart_2f8_P_interrupts_IDX_0 3
#define DT_N_S_soc_S_uart_2f8_P_interrupts_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_interrupts_IDX_1 256
#define DT_N_S_soc_S_uart_2f8_P_interrupts_IDX_1_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_interrupts_IDX_2 3
#define DT_N_S_soc_S_uart_2f8_P_interrupts_IDX_2_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_interrupts_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_2f8, interrupts, 0) \
	fn(DT_N_S_soc_S_uart_2f8, interrupts, 1) \
	fn(DT_N_S_soc_S_uart_2f8, interrupts, 2)
#define DT_N_S_soc_S_uart_2f8_P_interrupts_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_2f8, interrupts, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, interrupts, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_2f8, interrupts, 2, __VA_ARGS__)
#define DT_N_S_soc_S_uart_2f8_P_interrupts_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_interrupt_parent DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_uart_2f8_P_interrupt_parent_IDX_0 DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_uart_2f8_P_interrupt_parent_IDX_0_PH DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_uart_2f8_P_interrupt_parent_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_interrupt_parent_LEN 1
#define DT_N_S_soc_S_uart_2f8_P_interrupt_parent_EXISTS 1
#define DT_N_S_soc_S_uart_2f8_P_wakeup_source 0
#define DT_N_S_soc_S_uart_2f8_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /soc/uart@3f8
 *
 * Node identifier: DT_N_S_soc_S_uart_3f8
 *
 * Binding (compatible = ns16550):
 *   $ZEPHYR_BASE/dts/bindings/serial/ns16550.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_soc_S_uart_3f8_PATH "/soc/uart@3f8"

/* Node's name with unit-address: */
#define DT_N_S_soc_S_uart_3f8_FULL_NAME "uart@3f8"

/* Node parent (/soc) identifier: */
#define DT_N_S_soc_S_uart_3f8_PARENT DT_N_S_soc
#define DT_N_S_soc_S_uart_3f8_FOREACH_CHILD(fn) 
#define DT_N_S_soc_S_uart_3f8_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_soc_S_uart_3f8_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_soc_S_uart_3f8_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_soc_S_uart_3f8_ORD 21

/* Ordinals for what this node depends on directly: */
#define DT_N_S_soc_S_uart_3f8_REQUIRES_ORDS \
	16, /* /ioapic@fec00000 */ \
	17, /* /soc */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_soc_S_uart_3f8_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_soc_S_uart_3f8_EXISTS 1
#define DT_N_ALIAS_uart_0    DT_N_S_soc_S_uart_3f8
#define DT_N_INST_0_ns16550  DT_N_S_soc_S_uart_3f8
#define DT_N_NODELABEL_uart0 DT_N_S_soc_S_uart_3f8

/* Macros for properties that are special in the specification: */
#define DT_N_S_soc_S_uart_3f8_REG_NUM 1
#define DT_N_S_soc_S_uart_3f8_REG_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_REG_IDX_0_VAL_ADDRESS 1016 /* 0x3f8 */
#define DT_N_S_soc_S_uart_3f8_REG_IDX_0_VAL_SIZE 256 /* 0x100 */
#define DT_N_S_soc_S_uart_3f8_IRQ_NUM 1
#define DT_N_S_soc_S_uart_3f8_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_IRQ_IDX_0_VAL_irq 4
#define DT_N_S_soc_S_uart_3f8_IRQ_IDX_0_VAL_irq_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_IRQ_IDX_0_VAL_sense 256
#define DT_N_S_soc_S_uart_3f8_IRQ_IDX_0_VAL_sense_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_IRQ_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_IRQ_IDX_0_VAL_priority 3
#define DT_N_S_soc_S_uart_3f8_IRQ_IDX_0_VAL_priority_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_COMPAT_MATCHES_ns16550 1
#define DT_N_S_soc_S_uart_3f8_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_soc_S_uart_3f8_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_soc_S_uart_3f8_P_reg {1016 /* 0x3f8 */, 256 /* 0x100 */}
#define DT_N_S_soc_S_uart_3f8_P_reg_IDX_0 1016
#define DT_N_S_soc_S_uart_3f8_P_reg_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_reg_IDX_1 256
#define DT_N_S_soc_S_uart_3f8_P_reg_IDX_1_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_3f8, reg, 0) \
	fn(DT_N_S_soc_S_uart_3f8, reg, 1)
#define DT_N_S_soc_S_uart_3f8_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_3f8, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, reg, 1, __VA_ARGS__)
#define DT_N_S_soc_S_uart_3f8_P_reg_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_clock_frequency 1843200
#define DT_N_S_soc_S_uart_3f8_P_clock_frequency_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_current_speed 115200
#define DT_N_S_soc_S_uart_3f8_P_current_speed_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_label "UART_0"
#define DT_N_S_soc_S_uart_3f8_P_label_STRING_TOKEN UART_0
#define DT_N_S_soc_S_uart_3f8_P_label_STRING_UPPER_TOKEN UART_0
#define DT_N_S_soc_S_uart_3f8_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_3f8, label, 0) \
	fn(DT_N_S_soc_S_uart_3f8, label, 1) \
	fn(DT_N_S_soc_S_uart_3f8, label, 2) \
	fn(DT_N_S_soc_S_uart_3f8, label, 3) \
	fn(DT_N_S_soc_S_uart_3f8, label, 4) \
	fn(DT_N_S_soc_S_uart_3f8, label, 5)
#define DT_N_S_soc_S_uart_3f8_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_3f8, label, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, label, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, label, 2, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, label, 3, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, label, 4, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, label, 5, __VA_ARGS__)
#define DT_N_S_soc_S_uart_3f8_P_label_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_hw_flow_control 0
#define DT_N_S_soc_S_uart_3f8_P_hw_flow_control_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_status "okay"
#define DT_N_S_soc_S_uart_3f8_P_status_STRING_TOKEN okay
#define DT_N_S_soc_S_uart_3f8_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_soc_S_uart_3f8_P_status_ENUM_IDX 1
#define DT_N_S_soc_S_uart_3f8_P_status_ENUM_TOKEN okay
#define DT_N_S_soc_S_uart_3f8_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_soc_S_uart_3f8_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_3f8, status, 0) \
	fn(DT_N_S_soc_S_uart_3f8, status, 1) \
	fn(DT_N_S_soc_S_uart_3f8, status, 2) \
	fn(DT_N_S_soc_S_uart_3f8, status, 3)
#define DT_N_S_soc_S_uart_3f8_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_3f8, status, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, status, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, status, 2, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, status, 3, __VA_ARGS__)
#define DT_N_S_soc_S_uart_3f8_P_status_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_compatible {"ns16550"}
#define DT_N_S_soc_S_uart_3f8_P_compatible_IDX_0 "ns16550"
#define DT_N_S_soc_S_uart_3f8_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_3f8, compatible, 0)
#define DT_N_S_soc_S_uart_3f8_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_3f8, compatible, 0, __VA_ARGS__)
#define DT_N_S_soc_S_uart_3f8_P_compatible_LEN 1
#define DT_N_S_soc_S_uart_3f8_P_compatible_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_interrupts {4 /* 0x4 */, 256 /* 0x100 */, 3 /* 0x3 */}
#define DT_N_S_soc_S_uart_3f8_P_interrupts_IDX_0 4
#define DT_N_S_soc_S_uart_3f8_P_interrupts_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_interrupts_IDX_1 256
#define DT_N_S_soc_S_uart_3f8_P_interrupts_IDX_1_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_interrupts_IDX_2 3
#define DT_N_S_soc_S_uart_3f8_P_interrupts_IDX_2_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_interrupts_FOREACH_PROP_ELEM(fn) fn(DT_N_S_soc_S_uart_3f8, interrupts, 0) \
	fn(DT_N_S_soc_S_uart_3f8, interrupts, 1) \
	fn(DT_N_S_soc_S_uart_3f8, interrupts, 2)
#define DT_N_S_soc_S_uart_3f8_P_interrupts_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_soc_S_uart_3f8, interrupts, 0, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, interrupts, 1, __VA_ARGS__) \
	fn(DT_N_S_soc_S_uart_3f8, interrupts, 2, __VA_ARGS__)
#define DT_N_S_soc_S_uart_3f8_P_interrupts_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_interrupt_parent DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_uart_3f8_P_interrupt_parent_IDX_0 DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_uart_3f8_P_interrupt_parent_IDX_0_PH DT_N_S_ioapic_fec00000
#define DT_N_S_soc_S_uart_3f8_P_interrupt_parent_IDX_0_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_interrupt_parent_LEN 1
#define DT_N_S_soc_S_uart_3f8_P_interrupt_parent_EXISTS 1
#define DT_N_S_soc_S_uart_3f8_P_wakeup_source 0
#define DT_N_S_soc_S_uart_3f8_P_wakeup_source_EXISTS 1

/*
 * Chosen nodes
 */
#define DT_CHOSEN_zephyr_sram                    DT_N_S_memory_0
#define DT_CHOSEN_zephyr_sram_EXISTS             1
#define DT_CHOSEN_zephyr_flash                   DT_N_S_flash_500000
#define DT_CHOSEN_zephyr_flash_EXISTS            1
#define DT_CHOSEN_zephyr_console                 DT_N_S_soc_S_uart_3f8
#define DT_CHOSEN_zephyr_console_EXISTS          1
#define DT_CHOSEN_zephyr_shell_uart              DT_N_S_soc_S_uart_3f8
#define DT_CHOSEN_zephyr_shell_uart_EXISTS       1
#define DT_CHOSEN_zephyr_bt_uart                 DT_N_S_soc_S_uart_2f8
#define DT_CHOSEN_zephyr_bt_uart_EXISTS          1
#define DT_CHOSEN_zephyr_uart_pipe               DT_N_S_soc_S_uart_2f8
#define DT_CHOSEN_zephyr_uart_pipe_EXISTS        1
#define DT_CHOSEN_zephyr_bt_mon_uart             DT_N_S_soc_S_uart_2f8
#define DT_CHOSEN_zephyr_bt_mon_uart_EXISTS      1
#define DT_CHOSEN_zephyr_code_partition          DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000
#define DT_CHOSEN_zephyr_code_partition_EXISTS   1
#define DT_CHOSEN_zephyr_flash_controller        DT_N_S_sim_flash
#define DT_CHOSEN_zephyr_flash_controller_EXISTS 1
#define DT_COMPAT_fixed_partitions_LABEL_storage DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_1000
#define DT_COMPAT_fixed_partitions_LABEL_storage_EXISTS 1
#define DT_COMPAT_fixed_partitions_LABEL_image_0 DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_11000
#define DT_COMPAT_fixed_partitions_LABEL_image_0_EXISTS 1
#define DT_COMPAT_fixed_partitions_LABEL_image_1 DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_21000
#define DT_COMPAT_fixed_partitions_LABEL_image_1_EXISTS 1
#define DT_COMPAT_fixed_partitions_LABEL_eeprom_emu DT_N_S_sim_flash_S_flash_sim_0_S_partitions_S_partition_31000
#define DT_COMPAT_fixed_partitions_LABEL_eeprom_emu_EXISTS 1

/*
 * Macros for compatibles with status "okay" nodes
 */
#define DT_COMPAT_HAS_OKAY_qemu_x86_emulator 1
#define DT_COMPAT_HAS_OKAY_intel_x86 1
#define DT_COMPAT_HAS_OKAY_intel_ioapic 1
#define DT_COMPAT_HAS_OKAY_simple_bus 1
#define DT_COMPAT_HAS_OKAY_ns16550 1
#define DT_COMPAT_HAS_OKAY_intel_hpet 1
#define DT_COMPAT_HAS_OKAY_intel_e1000 1
#define DT_COMPAT_HAS_OKAY_soc_nv_flash 1
#define DT_COMPAT_HAS_OKAY_zephyr_sim_flash 1
#define DT_COMPAT_HAS_OKAY_fixed_partitions 1
#define DT_COMPAT_HAS_OKAY_zephyr_emu_eeprom 1
#define DT_COMPAT_HAS_OKAY_zephyr_sim_eeprom 1

/*
 * Macros for status "okay" instances of each compatible
 */
#define DT_N_INST_qemu_x86_emulator_NUM_OKAY 1
#define DT_N_INST_intel_x86_NUM_OKAY 1
#define DT_N_INST_intel_ioapic_NUM_OKAY 1
#define DT_N_INST_simple_bus_NUM_OKAY 1
#define DT_N_INST_ns16550_NUM_OKAY 2
#define DT_N_INST_intel_hpet_NUM_OKAY 1
#define DT_N_INST_intel_e1000_NUM_OKAY 1
#define DT_N_INST_soc_nv_flash_NUM_OKAY 2
#define DT_N_INST_zephyr_sim_flash_NUM_OKAY 1
#define DT_N_INST_fixed_partitions_NUM_OKAY 1
#define DT_N_INST_zephyr_emu_eeprom_NUM_OKAY 1
#define DT_N_INST_zephyr_sim_eeprom_NUM_OKAY 1
#define DT_FOREACH_OKAY_qemu_x86_emulator(fn) fn(DT_N)
#define DT_FOREACH_OKAY_VARGS_qemu_x86_emulator(fn, ...) fn(DT_N, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_qemu_x86_emulator(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_qemu_x86_emulator(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_intel_x86(fn) fn(DT_N_S_cpus_S_cpu_0)
#define DT_FOREACH_OKAY_VARGS_intel_x86(fn, ...) fn(DT_N_S_cpus_S_cpu_0, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_intel_x86(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_intel_x86(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_intel_ioapic(fn) fn(DT_N_S_ioapic_fec00000)
#define DT_FOREACH_OKAY_VARGS_intel_ioapic(fn, ...) fn(DT_N_S_ioapic_fec00000, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_intel_ioapic(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_intel_ioapic(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_simple_bus(fn) fn(DT_N_S_soc)
#define DT_FOREACH_OKAY_VARGS_simple_bus(fn, ...) fn(DT_N_S_soc, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_simple_bus(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_simple_bus(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_ns16550(fn) fn(DT_N_S_soc_S_uart_3f8) fn(DT_N_S_soc_S_uart_2f8)
#define DT_FOREACH_OKAY_VARGS_ns16550(fn, ...) fn(DT_N_S_soc_S_uart_3f8, __VA_ARGS__) fn(DT_N_S_soc_S_uart_2f8, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_ns16550(fn) fn(0) fn(1)
#define DT_FOREACH_OKAY_INST_VARGS_ns16550(fn, ...) fn(0, __VA_ARGS__) fn(1, __VA_ARGS__)
#define DT_FOREACH_OKAY_intel_hpet(fn) fn(DT_N_S_soc_S_hpet_fed00000)
#define DT_FOREACH_OKAY_VARGS_intel_hpet(fn, ...) fn(DT_N_S_soc_S_hpet_fed00000, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_intel_hpet(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_intel_hpet(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_intel_e1000(fn) fn(DT_N_S_soc_S_eth_febc0000)
#define DT_FOREACH_OKAY_VARGS_intel_e1000(fn, ...) fn(DT_N_S_soc_S_eth_febc0000, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_intel_e1000(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_intel_e1000(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_soc_nv_flash(fn) fn(DT_N_S_flash_500000) fn(DT_N_S_sim_flash_S_flash_sim_0)
#define DT_FOREACH_OKAY_VARGS_soc_nv_flash(fn, ...) fn(DT_N_S_flash_500000, __VA_ARGS__) fn(DT_N_S_sim_flash_S_flash_sim_0, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_soc_nv_flash(fn) fn(0) fn(1)
#define DT_FOREACH_OKAY_INST_VARGS_soc_nv_flash(fn, ...) fn(0, __VA_ARGS__) fn(1, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_sim_flash(fn) fn(DT_N_S_sim_flash)
#define DT_FOREACH_OKAY_VARGS_zephyr_sim_flash(fn, ...) fn(DT_N_S_sim_flash, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_sim_flash(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_sim_flash(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_fixed_partitions(fn) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions)
#define DT_FOREACH_OKAY_VARGS_fixed_partitions(fn, ...) fn(DT_N_S_sim_flash_S_flash_sim_0_S_partitions, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_fixed_partitions(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_fixed_partitions(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_emu_eeprom(fn) fn(DT_N_S_eeprom1)
#define DT_FOREACH_OKAY_VARGS_zephyr_emu_eeprom(fn, ...) fn(DT_N_S_eeprom1, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_emu_eeprom(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_emu_eeprom(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_sim_eeprom(fn) fn(DT_N_S_eeprom0)
#define DT_FOREACH_OKAY_VARGS_zephyr_sim_eeprom(fn, ...) fn(DT_N_S_eeprom0, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_sim_eeprom(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_sim_eeprom(fn, ...) fn(0, __VA_ARGS__)

/*
 * Bus information for status "okay" nodes of each compatible
 */
